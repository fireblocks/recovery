/* eslint-disable no-new */
/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable prefer-destructuring */
/* eslint-disable no-lonely-if */
/* eslint-disable no-continue */
/* eslint-disable no-restricted-syntax */
import fs from 'fs';
import path from 'path';
import AdmZip, { IZipEntry } from 'adm-zip';
import forge from 'node-forge';
import {
  DecryptRSAPrivateKeyError,
  InvalidRSAPrivateKeyError,
  InvalidRecoveryKitError,
  KeyIdMissingError,
  KeyRecoveryConfig,
  WalletMaster,
  NoMetadataError,
  NoRSAPassphraseError,
  PlayerData,
  RecoveredKeys,
  SigningKeyMetadata,
  MissingMasterKeyFile,
  CalculatedPrivateKeysets,
} from './types';
import { recoverAutoGeneratedPassphrase } from './recoverAGP';
import { parseMetadataFile } from './metadata';
import { recoverMobileKeyShare } from './mobileKey';
import { getPlayerId } from './players';
import { reconstructKeys } from './reconstructKeys';
import { recoverNCWMaster } from './ncw';
import { Algorithm, ECDSA, ECDSA_CMP, EDDSA, EDDSA_CMP } from './algorithms';

const recoverKeysShares = (
  zipFiles: IZipEntry[],
  signingKeys: { [key: string]: SigningKeyMetadata },
  mobilePass: string,
  rsaFileData: string,
  rsaPass: string,
): PlayerData => {
  const players: PlayerData = {};
  for (const file of zipFiles) {
    if (file.entryName.startsWith('MOBILE')) {
      const { keyId, playerId, value } = recoverMobileKeyShare(signingKeys, file.getData().toString(), mobilePass);
      if (players[keyId] === undefined) {
        players[keyId] = {};
      }
      players[keyId][playerId] = value;
    } else if (['metadata.json', 'RSA_PASSPHRASE'].includes(file.entryName) || file.entryName.endsWith('backup.public_key.pem')) {
      continue;
    } else {
      let cosigner: string;
      let keyId: string | undefined;
      if (file.entryName.includes('_')) {
        [cosigner, keyId] = file.entryName.split('_');
      } else {
        // Backwards compatability - backup includes just one ECDSA key
        if (Object.keys(signingKeys).length === 1) {
          cosigner = file.entryName;
          keyId = Object.keys(signingKeys)[0];
        } else {
          keyId = undefined;
        }
      }

      if (keyId) {
        let privateKey: forge.pki.rsa.PrivateKey;
        let data: unknown;
        try {
          data = file.getData().toString('binary');
          privateKey = forge.pki.decryptRsaPrivateKey(rsaFileData, rsaPass);
        } catch (e) {
          throw new DecryptRSAPrivateKeyError();
        }

        if (privateKey === null) {
          throw new InvalidRSAPrivateKeyError();
        }

        let decrypted: any;
        try {
          // @ts-ignore
          decrypted = Buffer.from(privateKey.decrypt(data, 'RSA-OAEP'), 'binary').toString('hex');
        } catch (e) {
          throw new InvalidRecoveryKitError();
        }

        const playerId = getPlayerId(keyId, cosigner!, true).toString();
        if (players[keyId] === undefined) {
          players[keyId] = {};
        }
        players[keyId][playerId] = BigInt(`0x${decrypted}`);
      }
    }
  }

  return players;
};

const tryGetRecoveredKeyForKeyset = (
  keysets: CalculatedPrivateKeysets,
  keysetId: number,
  isEcdsa: boolean,
): [boolean, string?, string?, string?] => {
  const privateKeyForKeyset = keysets[keysetId];
  if (privateKeyForKeyset === undefined) {
    return [false, undefined, undefined, undefined];
  }
  const valuesToCheck: Algorithm[] = isEcdsa ? [ECDSA, ECDSA_CMP] : [EDDSA, EDDSA_CMP];

  for (const algo of valuesToCheck) {
    if (privateKeyForKeyset[algo] !== undefined) {
      const { prvKey, pubKey, chainCode } = privateKeyForKeyset[algo]!;
      return [true, prvKey, pubKey, chainCode];
    }
  }

  return [false, undefined, undefined, undefined];
};

export const recoverKeys = (params: KeyRecoveryConfig): RecoveredKeys => {
  const zipData: Buffer =
    'zipBase64' in params ? Buffer.from(params.zipBase64, 'base64') : fs.readFileSync(path.resolve(params.zipPath));
  const rsaFileData: string =
    'rsaBase64' in params
      ? Buffer.from(params.rsaBase64, 'base64').toString()
      : fs.readFileSync(path.resolve(params.rsaPath), 'utf-8');
  const autoGeneratedPassphrase = !('mobilePass' in params);
  try {
    new AdmZip(zipData);
  } catch (e) {
    throw new InvalidRecoveryKitError();
  }
  const zip: AdmZip = new AdmZip(zipData);
  const zipFiles: IZipEntry[] = zip.getEntries();
  let metadataFile: IZipEntry | undefined;
  let agpFile: IZipEntry | undefined;

  for (const file of zipFiles) {
    if (file.entryName === 'metadata.json') {
      metadataFile = file;
      if (!autoGeneratedPassphrase || (autoGeneratedPassphrase && agpFile)) {
        break;
      }
    }
    if (autoGeneratedPassphrase && file.entryName === 'RSA_PASSPHRASE') {
      agpFile = file;
    }
  }

  if (!metadataFile) {
    throw new NoMetadataError();
  }
  if (autoGeneratedPassphrase && !agpFile) {
    throw new NoRSAPassphraseError();
  }

  const mobilePass = 'mobilePass' in params ? params.mobilePass! : recoverAutoGeneratedPassphrase(params, agpFile!);
  const {
    signingKeys,
    ncwWalletMasters: masterKeys,
    keysetThMapping,
    maxKeysetId,
  } = parseMetadataFile(metadataFile.getData().toString());

  if (params.recoverOnlyNCW) {
    let walletMaster: WalletMaster | undefined;
    if (masterKeys && Object.keys(masterKeys).length > 0) {
      walletMaster = recoverNCWMaster(zipFiles, forge.pki.decryptRsaPrivateKey(rsaFileData, params.rsaPass), masterKeys);
    } else {
      throw new MissingMasterKeyFile();
    }

    return { ncwWalletMaster: walletMaster };
  }

  const players: PlayerData = recoverKeysShares(zipFiles, signingKeys, mobilePass, rsaFileData, params.rsaPass);

  for (const keyId in signingKeys) {
    if (!Object.keys(players).includes(keyId)) {
      throw new KeyIdMissingError(keyId);
    }
  }

  const tmp: CalculatedPrivateKeysets | undefined = reconstructKeys(players, signingKeys);
  if (!tmp) {
    throw new Error('Mismatch between recovered keys and metadata - unable to continue');
  }
  const decryptedKeysets = tmp!;

  const recoveredKeys: RecoveredKeys = {};

  for (let keysetId = 1; keysetId <= maxKeysetId; keysetId += 1) {
    recoveredKeys[keysetId] = { ecdsaExists: false, eddsaExists: false, ecdsaMinAccount: -1, eddsaMinAccount: -1 };
    let [exists, prv, pub, chaincode] = tryGetRecoveredKeyForKeyset(decryptedKeysets, keysetId, true);
    recoveredKeys[keysetId].ecdsaExists = exists;
    if (exists) {
      const keysetThMappingForAlgo = keysetThMapping[ECDSA]!;
      let minAccount = keysetId === 1 ? 0 : -1;
      // If ECDSA exists but there is not ECDSA mapping for threshold, this means that this is the only key and is the minimal account;
      if (keysetThMappingForAlgo === undefined) {
        minAccount = 0;
      }
      // Even if we have the key of a keyset, it might not exist in the threshold mapping
      else if (keysetThMappingForAlgo[keysetId] !== undefined) {
        minAccount = keysetThMappingForAlgo[keysetId];
      }
      recoveredKeys[keysetId] = {
        xprv: prv,
        xpub: pub,
        chainCodeEcdsa: chaincode,
        ...recoveredKeys[keysetId],
        ecdsaMinAccount: minAccount,
      };
    }
    [exists, prv, pub, chaincode] = tryGetRecoveredKeyForKeyset(decryptedKeysets, keysetId, false);
    recoveredKeys[keysetId].eddsaExists = exists;
    if (exists) {
      const keysetThMappingForAlgo = keysetThMapping[EDDSA]!;
      // Even if we have the key of a keyset, it might not exist in the threshold mapping
      let minAccount = keysetId === 1 ? 0 : -1;
      // If EDDSA exists but there is not EDDSA mapping for threshold, this means that this is the only key and is the minimal account;
      if (keysetThMappingForAlgo === undefined) {
        minAccount = 0;
      } else if (keysetThMappingForAlgo[keysetId] !== undefined) {
        minAccount = keysetThMappingForAlgo[keysetId];
      }

      recoveredKeys[keysetId] = {
        fprv: prv,
        fpub: pub,
        chainCodeEddsa: chaincode,
        ...recoveredKeys[keysetId],
        eddsaMinAccount: minAccount,
      };
    }

    if (!params.recoveryPrv) {
      delete recoveredKeys[keysetId].xprv;
      delete recoveredKeys[keysetId].fprv;
    }
  }

  let walletMaster: WalletMaster | undefined;
  if (masterKeys && Object.keys(masterKeys).length > 0) {
    walletMaster = recoverNCWMaster(zipFiles, forge.pki.decryptRsaPrivateKey(rsaFileData, params.rsaPass), masterKeys);
    recoveredKeys.ncwWalletMaster = walletMaster;
  }

  return recoveredKeys;
};
