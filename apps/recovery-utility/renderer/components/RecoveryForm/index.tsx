import { useRouter } from 'next/router';
import { forwardRef, useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import {
  recoverKeysInput,
  TextField,
  Button,
  UploadWell,
  BaseModal,
  useWrappedState,
  useOfflineMutation,
  UtilityExtendedKeys,
} from '@fireblocks/recovery-shared';
import { Checkbox, FormControlLabel, Typography, Box, Grid, Tooltip, Divider, Chip } from '@mui/material';
import { readFileToBase64 } from '@fireblocks/recovery-shared/lib/readFile';
import { WalletMaster } from '@fireblocks/extended-key-recovery';
import { RecoveredKey } from '@fireblocks/extended-key-recovery/src/types';
import { useWorkspace } from '../../context/Workspace';
import { recoverExtendedKeys } from '../../lib/recoverExtendedKeys';
import { TextFieldProps } from '@fireblocks/recovery-shared/components';

type FormData = z.infer<typeof recoverKeysInput>;

type Props = {
  verifyOnly?: boolean;
};

export const RecoveryForm = ({ verifyOnly }: Props) => {
  const router = useRouter();

  const { setExtendedKeys, addAccount } = useWorkspace();

  const [recoveryError, setRecoveryError] = useWrappedState<string | undefined>('recoveryError', undefined);
  const [recoveryData, setRecoveryData] = useState<FormData | undefined>(undefined); // Do not track, confidential data
  const [recoveryConfirmed, setRecoveryConfirmed] = useWrappedState<boolean>('recoveryConfirmed', false);

  const [jsonPassphrases, setJsonPassphrases] = useState<{ passphrase?: string; rsaKeyPassphrase?: string } | null>(null);
  const [jsonUploadError, setJsonUploadError] = useState<string | undefined>(undefined);

  const {
    register,
    setValue,
    handleSubmit,
    watch,
    formState: { errors },
  } = useForm<FormData>({
    resolver: zodResolver(recoverKeysInput),
    defaultValues: {
      backupZip: '',
      rsaKey: '',
      passphrase: '',
      rsaKeyPassphrase: '',
      agpRsaKey: '',
      agpRsaPassphrase: '',
      passphraseJson: null,
    },
  });

  const [backupZip, rsaKey, agpRsaKey, autoGeneratedPass, recoverOnlyNCW] = watch([
    'backupZip',
    'rsaKey',
    'agpRsaKey',
    'autoGeneratedPass',
    'recoverOnlyNCW',
  ]);

  const recoverMutation = useOfflineMutation({
    mutationFn: async (formData: FormData) =>
      recoverExtendedKeys({
        zip: formData.backupZip,
        mobilePassphrase:
          formData.passphraseJson !== null
            ? formData.passphraseJson.passphrase
            : formData.autoGeneratedPass
            ? formData.agpRsaPassphrase
            : formData.passphrase,
        rsaKey: formData.rsaKey,

        rsaKeyPassphrase: formData.passphraseJson !== null ? formData.passphraseJson.rsaKeyPassphrase : formData.rsaKeyPassphrase,

        autoGeneratedPassphrase: formData.autoGeneratedPass,
        mobileRsa: formData.agpRsaKey,
        recoverOnlyNCW: formData.recoverOnlyNCW,
        dangerouslyRecoverPrivateKeys: !verifyOnly,
      }),
    onSuccess: async (recoveredKeys) => {
      setRecoveryError(undefined);

      if (recoverOnlyNCW) {
        const ncwKey = { ncwMaster: recoveredKeys.ncwWalletMaster };
        setExtendedKeys(ncwKey);
        router.push('/ncw');
        return;
      }

      const maskedExtendedKeys: UtilityExtendedKeys = {};

      Object.entries(recoveredKeys).forEach(([keysetId, value]) => {
        if (keysetId === 'ncwMaster' && !verifyOnly) {
          maskedExtendedKeys.ncwMaster = value as WalletMaster | undefined;
          return;
        }

        maskedExtendedKeys[Number(keysetId)] = {
          ...(value as RecoveredKey),
          ...(verifyOnly ? { xprv: undefined, fprv: undefined } : {}),
        };
      });

      setExtendedKeys(maskedExtendedKeys);

      addAccount('Default', 0);

      if (verifyOnly) {
        router.push({ pathname: '/keys', query: { verifyOnly: 'true' } });
      } else {
        router.push('/accounts/vault');
      }
    },
    onError: (error) => {
      console.error(error);

      setRecoveryError(error instanceof Error ? error.message : (error as string));
    },
  });

  const onDropBackupZip = async (file: File) => setValue('backupZip', await readFileToBase64(file));

  const onDropRsaPrivateKey = async (file: File) => setValue('rsaKey', await readFileToBase64(file));

  const onDropAGPRsaPrivateKey = async (file: File) => setValue('agpRsaKey', await readFileToBase64(file));

  const onDropPassphraseJson = async (file: File) => {
    try {
      const base64Content = await readFileToBase64(file);
      const jsonContent = atob(base64Content.split(',')[1] || base64Content);
      const parsedJson = JSON.parse(jsonContent);

      // Validate JSON structure
      if (typeof parsedJson !== 'object' || parsedJson === null) {
        throw new Error('Invalid JSON format');
      }

      // Create the passphrase object with only the two required fields
      const passphraseObject = {
        passphrase: parsedJson.passphrase || undefined,
        rsaKeyPassphrase: parsedJson.rsaKeyPassphrase || undefined,
      };

      if (!passphraseObject.passphrase && !passphraseObject.rsaKeyPassphrase) {
        throw new Error('JSON must contain at least one of: passphrase, rsaKeyPassphrase');
      }

      // Set the object directly to the form
      setValue('passphraseJson', passphraseObject);
      setJsonPassphrases(passphraseObject);
      setJsonUploadError(undefined);

      // Auto-populate form fields if JSON upload is successful
      if (passphraseObject.passphrase) {
        setValue('passphrase', passphraseObject.passphrase);
      }
      if (passphraseObject.rsaKeyPassphrase) {
        setValue('rsaKeyPassphrase', passphraseObject.rsaKeyPassphrase);
      }
    } catch (error) {
      setJsonUploadError(error instanceof Error ? error.message : 'Failed to parse JSON file');
      setValue('passphraseJson', null); // Set to null instead of undefined
    }
  };

  const onSubmit = (formData: FormData) =>
    verifyOnly || recoverOnlyNCW ? recoverMutation.mutate(formData) : setRecoveryData(formData);

  const onConfirmRecover = () => recoverMutation.mutate(recoveryData as FormData);

  const CustomTextField = forwardRef<HTMLInputElement, TextFieldProps>((props, ref) => {
    return <TextField {...props} ref={ref} />;
  });

  return (
    <>
      <Box
        component='form'
        height='100%'
        display='flex'
        flexDirection='column'
        onSubmit={handleSubmit(onSubmit)}
        onKeyUp={(event) => {
          if (event.shiftKey === false && event.key === 'Enter') {
            handleSubmit(onSubmit);
          }
        }}
      >
        <Typography variant='h1' component='h2'>
          {verifyOnly ? 'Verify Recovery Kit' : 'Recover Private Keys'}
        </Typography>
        {verifyOnly ? (
          <Typography variant='body1' paragraph>
            Use this tool to recover your Fireblocks extended public keys, then check that they match the keys in your Fireblocks
            Console Settings. Derive wallet public keys to check that their addresses match. This does not expose your private
            keys.
          </Typography>
        ) : (
          <Typography variant='body1' color={(theme) => theme.palette.error.main} paragraph>
            Using private key recovery exposes your private keys to this system. Only do this in a disaster recovery scenario, and
            then move your assets to other secure wallets. Use the Fireblocks Console, APIs, and SDKs for standard operations.
          </Typography>
        )}
        <Grid container spacing={3}>
          <Grid item xs={6}>
            <UploadWell
              label='Recovery Kit'
              error={errors.backupZip?.message}
              hasFile={!!backupZip}
              accept={{ 'application/zip': ['.zip'] }}
              disabled={recoverMutation.isLoading}
              onDrop={onDropBackupZip}
              id={process.env.CI === 'e2e' ? 'recovery-kit-upload-well' : undefined}
            />
          </Grid>
          <Grid item xs={6}>
            <UploadWell
              label='Recovery Private Key'
              error={errors.rsaKey?.message}
              hasFile={!!rsaKey}
              accept={{ 'application/x-pem-file': ['.key', '.pem'] }}
              disabled={recoverMutation.isLoading}
              onDrop={onDropRsaPrivateKey}
              id={process.env.CI === 'e2e' ? 'recovery-kit-key-upload-well' : undefined}
            />
          </Grid>
          <Grid item xs={6}>
            {autoGeneratedPass ? (
              <TextField
                id='agpRsaKeyPassphrase'
                type='password'
                label='Auto-generated passphrase'
                error={errors.agpRsaPassphrase?.message}
                disabled={recoverMutation.isLoading}
                {...register('agpRsaPassphrase')}
              />
            ) : (
              <Tooltip title={recoverOnlyNCW ? 'Mobile passphrase is not required for NCW wallets recovery' : ''}>
                <CustomTextField
                  id='passphrase'
                  type={recoverOnlyNCW ? 'text' : 'password'}
                  label='Mobile App Recovery Passphrase'
                  helpText='Set by the workspace owner during onboarding'
                  error={errors.passphrase?.message}
                  disabled={recoverMutation.isLoading || recoverOnlyNCW}
                  {...register('passphrase')}
                  sx={{
                    '& input[disabled]': {
                      backgroundColor: 'rgba(0, 0, 0, 0.12)',
                    },
                  }}
                />
              </Tooltip>
            )}
          </Grid>
          <Grid item xs={6}>
            <TextField
              id='rsaKeyPassphrase'
              type='password'
              label='Recovery Private Key Passphrase'
              error={errors.rsaKeyPassphrase?.message}
              disabled={recoverMutation.isLoading}
              {...register('rsaKeyPassphrase')}
            />
          </Grid>

          <Grid item xs={6}>
            <FormControlLabel
              control={<Checkbox id='autoGeneratedPass' {...register('autoGeneratedPass')} />}
              label='Use auto-generated passphrase'
            />
          </Grid>
          {!verifyOnly && (
            <Grid item xs={6}>
              <FormControlLabel
                control={<Checkbox id='recoverOnlyNCW' {...register('recoverOnlyNCW')} />}
                label='Recover Non-Custodial Wallets (Embedded) only'
              />
            </Grid>
          )}

          <Grid item xs={6}>
            <UploadWell
              label='Auto-generated passphrase private key'
              error={errors.agpRsaKey?.message}
              hasFile={!!agpRsaKey}
              accept={{ 'application/x-pem-file': ['.key', '.pem'] }}
              disabled={recoverMutation.isLoading}
              hidden={!autoGeneratedPass}
              onDrop={onDropAGPRsaPrivateKey}
            />
          </Grid>
        </Grid>

        <Grid item xs={12}>
          <Divider>
            <Chip label='OR' />
          </Divider>
        </Grid>
        <Grid item xs={12}>
          <UploadWell
            label='Upload Passphrase JSON File'
            error={jsonUploadError || errors.passphraseJson?.message}
            hasFile={jsonPassphrases !== null}
            accept={{ 'application/json': ['.json'] }}
            disabled={recoverMutation.isLoading}
            onDrop={onDropPassphraseJson}
            id={process.env.CI === 'e2e' ? 'passphrase-json-upload-well' : undefined}
          />
        </Grid>

        <Grid container spacing={2} alignItems='center' justifyContent='flex-end' marginTop='auto'>
          <Grid item flex='1'>
            <Typography variant='body1' fontWeight='600' color={(theme) => theme.palette.error.main}>
              {recoveryError}
            </Typography>
          </Grid>
          <Grid item>
            <Button type='submit' color='primary' disabled={recoverMutation.isLoading}>
              {verifyOnly ? 'Verify Recovery Kit' : 'Recover'}
            </Button>
          </Grid>
        </Grid>
      </Box>
      <BaseModal
        open={!!recoveryData && !verifyOnly && !recoverOnlyNCW}
        actions={
          <Box display='flex' width='100%' justifyContent='space-between'>
            <FormControlLabel
              control={<Checkbox onChange={(_) => setRecoveryConfirmed(!recoveryConfirmed)} />}
              label='I want to recover my private key'
            />
            <Button
              color='primary'
              disabled={!recoveryConfirmed}
              onClick={() => {
                onConfirmRecover();
                setRecoveryData(undefined);
                setRecoveryConfirmed(false);
              }}
            >
              Confirm
            </Button>
          </Box>
        }
        title='Confirm Recovery'
        onClose={() => setRecoveryData(undefined)}
      >
        <Typography variant='body1' color={(theme) => theme.palette.error.main}>
          You are about to recover the workspace private key materials. This means that for the first time since their creation,
          the private keys will be reconstructed in a single location.
          <br />
          <br />
          Recovering will allow you to withdraw your assets. If you are only interested in verifying, please use the verify
          operation instead.
          <br />
          <br />
          Please confirm you would like to reconstruct the private keys.
        </Typography>
      </BaseModal>
    </>
  );
};
